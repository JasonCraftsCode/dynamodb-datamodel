## API Report File for "dynamodb-datamodel"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { DocumentClient } from 'aws-sdk/clients/dynamodb';
import { ExpressionAttributeNameMap } from 'aws-sdk/clients/dynamodb';

// @public
export class Condition {
    static and(...conditions: Condition.Resolver[]): Condition.Resolver;
    static beginsWith(path: string, value: string): Condition.Resolver;
    static between(path: string, from: Condition.Value, to: Condition.Value): Condition.Resolver;
    static compare(left: Condition.Path, op: Condition.CompareOperators, right: Condition.Value): Condition.Resolver;
    static contains(path: string, value: string): Condition.Resolver;
    static eq(left: Condition.Path, right: Condition.Value): Condition.Resolver;
    static exists(path: string): Condition.Resolver;
    static ge(left: Condition.Path, right: Condition.Value): Condition.Resolver;
    static gt(left: Condition.Path, right: Condition.Value): Condition.Resolver;
    static in(path: string, values: Condition.Value[]): Condition.Resolver;
    static le(left: Condition.Path, right: Condition.Value): Condition.Resolver;
    static lt(left: Condition.Path, right: Condition.Value): Condition.Resolver;
    static ne(left: Condition.Path, right: Condition.Value): Condition.Resolver;
    static not(condition: Condition.Resolver): Condition.Resolver;
    static notExists(path: string): Condition.Resolver;
    static or(...conditions: Condition.Resolver[]): Condition.Resolver;
    static path(value: string): Condition.ValueResolver;
    static size(path: string): Condition.ValueResolver;
    static type(path: string, type: Table.AttributeTypes): Condition.Resolver;
}

// @public
export namespace Condition {
    export type CompareOperators = '=' | '<>' | '<' | '<=' | '>' | '>=';
    export interface Expression {
        addPath(path: string): string;
        addValue(value: Table.AttributeValues): string;
        resolvePath(path: Condition.Path): string;
        resolveValues(values: Condition.Value[]): string[];
    }
    export type LogicalOperators = 'AND' | 'OR' | 'NOT';
    export type Operators = CompareOperators | 'BETWEEN' | 'IN' | 'begins_with' | 'contains' | 'attribute_type' | 'attribute_exists' | 'attribute_not_exists' | 'size' | LogicalOperators;
    export type Path = string | ValueResolver;
    export type Resolver = (exp: Expression, type: 'BOOL') => string;
    export type Value<T extends Table.AttributeValues = Table.AttributeValues> = T | ValueResolver;
    export type ValueResolver = (exp: Expression, type: 'S') => string;
}

// @public
export class ConditionExpression implements Condition.Expression {
    constructor(attributes: Table.ExpressionAttributes);
    static addParams(params: {
        ConditionExpression?: string;
        FilterExpression?: string;
    }, attributes: Table.ExpressionAttributes, type: 'filter' | 'condition', conditions?: Condition.Resolver[]): void;
    addPath(path: string): string;
    addValue(value: Table.AttributeValues): string;
    attributes: Table.ExpressionAttributes;
    static buildExpression(conditions: Condition.Resolver[], exp: Condition.Expression): string;
    static isResolver(value: Condition.Path | Condition.Value): value is Condition.ValueResolver;
    resolvePath(path: Condition.Path): string;
    resolveValues(values: Condition.Value[]): string[];
}

// @public
export class ExpressionAttributes implements Table.ExpressionAttributes {
    static addParams(params: Table.ExpressionAttributeParams, attributes: Table.ExpressionAttributes): void;
    addPath(name: string): string;
    addValue(value: Table.AttributeValues): string;
    getPaths(): ExpressionAttributeNameMap | void;
    getValues(): Table.AttributeValuesMap | void;
    isReservedName: (name: string) => boolean;
    static isValidAttributeName(name: string): boolean;
    isValidName: (name: string) => boolean;
    names: ExpressionAttributeNameMap;
    nextName: number;
    nextValue: number;
    pathDelimiter: string;
    treatNameAsPath: boolean;
    static validAttributeNameRegEx: RegExp;
    values: Table.AttributeValuesMap;
}

// @public
export class Fields {
    static binary(options?: Fields.BaseOptions<Table.BinaryValue>): Fields.FieldBinary;
    static binarySet(options?: Fields.BaseOptions<Table.BinarySetValue>): Fields.FieldBinarySet;
    static boolean(options?: Fields.BaseOptions<boolean>): Fields.FieldBoolean;
    static composite(options: Fields.CompositeOptions): Fields.FieldComposite;
    static compositeNamed<T extends {
        [key: string]: number;
    }>(options: Fields.CompositeNamedOptions<T>): Fields.FieldCompositeNamed<T>;
    static createdDate(options?: Fields.CreatedDateOptions): Fields.FieldCreatedDate;
    static date(options?: Fields.BaseOptions<Date>): Fields.FieldDate;
    static hidden(): Fields.FieldHidden;
    static list(options?: Fields.BaseOptions<Table.ListValue>): Fields.FieldList<Table.AttributeValues>;
    static map(options?: Fields.BaseOptions<Table.MapValue>): Fields.FieldMap<Table.AttributeValues>;
    static model<V>(options: Fields.ModelOptions<V>): Fields.FieldModel<V>;
    static modelList<V>(options: Fields.ModelListOptions<V>): Fields.FieldModelList<V>;
    static modelMap<V>(options: Fields.ModelMapOptions<V>): Fields.FieldModelMap<V>;
    static number(options?: Fields.BaseOptions<number>): Fields.FieldNumber;
    static numberSet(options?: Fields.BaseOptions<Table.NumberSetValue>): Fields.FieldNumberSet;
    static revision(options?: Fields.RevisionOptions): Fields.FieldRevision;
    static split(options: Fields.SplitOptions): Fields.FieldSplit;
    static string(options?: Fields.BaseOptions<string>): Fields.FieldString;
    static stringSet(options?: Fields.BaseOptions<Table.StringSetValue>): Fields.FieldStringSet;
    static type(options?: Fields.TypeOptions): Fields.FieldType;
    static updatedDate(options?: Fields.UpdateDateOptions): Fields.FieldUpdatedDate;
}

// @public
export namespace Fields {
    export interface AttributeDefinition {
        type: Table.AttributeTypes;
    }
    export type AttributesSchema = {
        [key: string]: AttributeDefinition;
    };
    export interface BaseOptions<V> {
        alias?: string;
        default?: V | FieldBase.DefaultFunction<V>;
    }
    export interface CompositeNamedOptions<T extends {
        [index: string]: number;
    }> extends CompositeOptions {
        map: T;
    }
    export interface CompositeOptions {
        alias: string;
        count?: number;
        delimiter?: string;
    }
    export type CompositeSlotMap<T extends {
        [index: string]: number;
    }, V extends {
        [index: string]: Field;
    } = {}> = V & {
        [P in keyof T]: FieldCompositeSlot;
    };
    export interface CreatedDateOptions {
        alias?: string;
        now?: () => Date;
    }
    export interface Field {
        getAttributesSchema?(): AttributesSchema;
        init(name: string, model: Model): void;
        toModel(name: string, tableData: Table.AttributeValuesMap, modelData: Model.ModelData, context: ModelContext): void;
        toTable(name: string, modelData: Model.ModelData, tableData: Table.AttributeValuesMap, context: TableContext): void;
        toTableUpdate?(name: string, modelData: Model.ModelUpdate, tableData: Update.ResolverMap, context: TableContext): void;
    }
    export class FieldBase<V> implements Field {
        constructor(options?: BaseOptions<V>);
        alias?: string;
        default?: V | FieldBase.DefaultFunction<V>;
        getDefault(name: string, modelData: Model.ModelData, context: TableContext): V | undefined;
        init(name: string, model: Model): void;
        name?: string;
        tableName(): string;
        toModel(name: string, tableData: Table.AttributeValuesMap, modelData: Model.ModelData, context: ModelContext): void;
        toTable(name: string, modelData: Model.ModelData, tableData: Table.AttributeValuesMap, context: TableContext): void;
        toTableUpdate(name: string, modelData: Model.ModelUpdate, tableData: Update.ResolverMap, context: TableContext): void;
    }
    export namespace FieldBase {
        export type DefaultFunction<T> = (name: string, modelData: Model.ModelData, context: TableContext) => T;
    }
    export class FieldBinary extends FieldExpression<Table.BinaryValue, 'B'> {
        size(): Condition.ValueResolver;
    }
    export class FieldBinarySet extends FieldSet<Table.BinarySetValue, 'BS'> {
    }
    export class FieldBoolean extends FieldExpression<boolean, 'BOOL'> {
    }
    export class FieldComposite {
        constructor(options: CompositeOptions);
        alias: string;
        count: number;
        createSlots(): FieldCompositeSlot[];
        delimiter: string;
    }
    export class FieldCompositeNamed<T extends {
        [index: string]: number;
    }> extends FieldComposite {
        constructor(options: CompositeNamedOptions<T>);
        createNamedSlots(): CompositeSlotMap<T>;
        map: T;
    }
    export class FieldCompositeSlot implements Field {
        constructor(composite: FieldComposite, slot: number, slots: FieldCompositeSlot[]);
        composite: FieldComposite;
        init(name: string, model: Model): void;
        name?: string;
        slot: number;
        slots: FieldCompositeSlot[];
        toModel(name: string, tableData: Table.AttributeValuesMap, modelData: Model.ModelData, context: ModelContext): void;
        toTable(name: string, modelData: Model.ModelData, tableData: Table.AttributeValuesMap, context: TableContext): void;
        toTableUpdate(name: string, modelData: Model.ModelUpdate, tableData: Update.ResolverMap, context: TableContext): void;
    }
    export class FieldCreatedDate implements Fields.Field {
        constructor(options?: CreatedDateOptions);
        alias?: string;
        init(name: string, model: Model): void;
        name?: string;
        now: () => Date;
        toModel(name: string, tableData: Table.AttributeValuesMap, modelData: Model.ModelData, context: Fields.ModelContext): void;
        toTable(name: string, modelData: Model.ModelData, tableData: Table.AttributeValuesMap, context: Fields.TableContext): void;
    }
    export class FieldDate extends FieldBase<Date> {
        toModel(name: string, tableData: Table.AttributeValuesMap, modelData: Model.ModelData, context: ModelContext): void;
        toTable(name: string, modelData: Model.ModelData, tableData: Table.AttributeValuesMap, context: TableContext): void;
        toTableUpdate(name: string, modelData: Model.ModelUpdate, tableData: Update.ResolverMap, context: TableContext): void;
    }
    export class FieldExpression<V, T extends Table.AttributeTypes> extends FieldBase<V> {
        between(from: Condition.Value<V>, to: Condition.Value<V>): Condition.Resolver;
        eq(v: Condition.Value<V>): Condition.Resolver;
        exists(): Condition.Resolver;
        ge(v: Condition.Value<V>): Condition.Resolver;
        gt(v: Condition.Value<V>): Condition.Resolver;
        in(v: Condition.Value<V>[]): Condition.Resolver;
        le(v: Condition.Value<V>): Condition.Resolver;
        lt(v: Condition.Value<V>): Condition.Resolver;
        ne(v: Condition.Value<V>): Condition.Resolver;
        notExists(): Condition.Resolver;
        path(): Condition.ValueResolver;
        type(type: Table.AttributeTypes): Condition.Resolver;
    }
    export class FieldHidden implements Fields.Field {
        init(name: string, model: Model): void;
        toModel(name: string, tableData: Table.AttributeValuesMap, modelData: Model.ModelData, context: ModelContext): void;
        toTable(name: string, modelData: Model.ModelData, tableData: Table.AttributeValuesMap, context: TableContext): void;
    }
    export class FieldList<V extends Table.AttributeValues> extends FieldExpression<V[], 'L'> {
        size(): Condition.ValueResolver;
    }
    export class FieldMap<V extends Table.AttributeValues> extends FieldExpression<{
        [key: string]: V;
    }, 'M'> {
        size(): Condition.ValueResolver;
    }
    export class FieldModel<V extends {
        [key: string]: any;
    }> extends FieldExpression<V, 'M'> {
        constructor(options: ModelOptions<V>);
        init(name: string, model: Model): void;
        schema: Model.ModelSchemaT<V>;
        size(): Condition.ValueResolver;
    }
    export class FieldModelList<V extends {
        [key: string]: any;
    }> extends FieldList<V> {
        constructor(options: ModelListOptions<V>);
        init(name: string, model: Model): void;
        schema: Model.ModelSchemaT<V>;
    }
    export class FieldModelMap<V extends {
        [key: string]: any;
    }> extends FieldMap<V> {
        constructor(options: ModelMapOptions<V>);
        init(name: string, model: Model): void;
        schema: Model.ModelSchemaT<V>;
    }
    export class FieldNull extends FieldExpression<null, 'NULL'> {
    }
    export class FieldNumber extends FieldExpression<number, 'N'> {
    }
    export class FieldNumberSet extends FieldSet<Table.NumberSetValue, 'NS'> {
    }
    export class FieldRevision implements Fields.Field {
        constructor(options?: RevisionOptions);
        alias?: string;
        init(name: string, model: Model): void;
        matchOnWrite?: boolean;
        name?: string;
        start: number;
        toModel(name: string, tableData: Table.AttributeValuesMap, modelData: Model.ModelData, context: Fields.ModelContext): void;
        toTable(name: string, modelData: Model.ModelData, tableData: Table.AttributeValuesMap, context: Fields.TableContext): void;
        toTableUpdate(name: string, modelData: Model.ModelUpdate, tableData: Update.ResolverMap, context: Fields.TableContext): void;
    }
    export class FieldSet<V, T extends 'BS' | 'NS' | 'SS'> extends FieldExpression<V, T> {
        contains(value: string): Condition.Resolver;
        size(): Condition.ValueResolver;
    }
    export class FieldSplit implements Field {
        constructor(options: SplitOptions);
        aliases: string[];
        delimiter: string;
        init(name: string, model: Model): void;
        name?: string;
        toModel(name: string, tableData: Table.AttributeValuesMap, modelData: Model.ModelData, context: ModelContext): void;
        toTable(name: string, modelData: Model.ModelData, tableData: Table.AttributeValuesMap, context: TableContext): void;
        toTableUpdate(name: string, modelData: Model.ModelUpdate, tableData: Update.ResolverMap, context: TableContext): void;
    }
    export class FieldString extends FieldExpression<string, 'S'> {
        beginsWith(value: string): Condition.Resolver;
        contains(value: string): Condition.Resolver;
        size(): Condition.ValueResolver;
    }
    export class FieldStringSet extends FieldSet<Table.StringSetValue, 'SS'> {
    }
    export class FieldType implements Field {
        constructor(options?: TypeOptions);
        alias?: string;
        init(name: string, model: Model): void;
        name?: string;
        toModel(name: string, tableData: Table.AttributeValuesMap, modelData: Model.ModelData, context: Fields.ModelContext): void;
        toTable(name: string, modelData: Model.ModelData, tableData: Table.AttributeValuesMap, context: Fields.TableContext): void;
    }
    export class FieldUpdatedDate implements Fields.Field {
        constructor(options?: UpdateDateOptions);
        alias?: string;
        init(name: string, model: Model): void;
        name?: string;
        now: () => Date;
        toModel(name: string, tableData: Table.AttributeValuesMap, modelData: Model.ModelData, context: Fields.ModelContext): void;
        toTable(name: string, modelData: Model.ModelData, tableData: Table.AttributeValuesMap, context: Fields.TableContext): void;
        toTableUpdate(name: string, modelData: Model.ModelUpdate, tableData: Update.ResolverMap, context: Fields.TableContext): void;
    }
    export interface ModelContext {
        action: Table.ItemActions;
        model: Model.ModelBase;
        options: Table.BaseOptions;
    }
    export interface ModelListOptions<V> extends BaseOptions<V[]> {
        schema: Model.ModelSchemaT<V>;
    }
    export interface ModelMapOptions<V> extends BaseOptions<{
        [key: string]: V;
    }> {
        schema: Model.ModelSchemaT<V>;
    }
    export interface ModelOptions<V> extends BaseOptions<V> {
        schema: Model.ModelSchemaT<V>;
    }
    export interface RevisionOptions {
        alias?: string;
        matchOnWrite?: boolean;
        start?: number;
    }
    export interface SplitOptions {
        aliases: string[];
        delimiter?: string;
    }
    export interface TableContext {
        action: Table.ItemActions;
        conditions: Condition.Resolver[];
        model: Model.ModelBase;
        options: Table.BaseOptions;
    }
    export interface TypeOptions {
        alias?: string;
    }
    export interface UpdateDateOptions {
        alias?: string;
        now?: () => Date;
    }
}

// @public
export class Index {
    constructor(params: Index.IndexParams);
    getPartitionKey(): string;
    getQueryOptions(options?: Table.QueryOptions): Table.QueryOptions;
    getScanOptions(options?: Table.ScanOptions): Table.ScanOptions;
    getSortKey(): string;
    init(table: Table): void;
    keySchema: Table.PrimaryKey.KeyTypesMap;
    name: string;
    projection: {
        attributes?: string[];
        type: Table.ProjectionType;
    };
    query(key: Table.PrimaryKey.KeyQueryMap, options?: Table.QueryOptions): Promise<DocumentClient.QueryOutput>;
    queryParams(key: Table.PrimaryKey.KeyQueryMap, options?: Table.QueryOptions): DocumentClient.QueryInput;
    scan(options?: Table.ScanOptions): Promise<DocumentClient.ScanOutput>;
    scanParams(options?: Table.ScanOptions): DocumentClient.ScanInput;
    table?: Table;
}

// @public
export namespace Index {
    export function createIndex<KEY = DefaultGlobalIndexKey>(params: IndexParamsT<KEY>): IndexT<KEY>;
    export interface DefaultGlobalIndexKey {
        G0P: Table.PrimaryKey.PartitionString;
        G0S?: Table.PrimaryKey.SortString;
    }
    export interface DefaultLocalIndexKey {
        L0S?: Table.PrimaryKey.SortString;
        P: Table.PrimaryKey.PartitionString;
    }
    export interface IndexParams {
        keySchema: Table.PrimaryKey.KeyTypesMap;
        name: string;
        projection: {
            attributes?: string[];
            type: Table.ProjectionType;
        };
    }
    export interface IndexParamsT<KEY> extends IndexParams {
        keySchema: Table.PrimaryKey.KeyTypesMapT<KEY>;
    }
    export interface IndexT<KEY = DefaultGlobalIndexKey> extends Index {
        keySchema: Table.PrimaryKey.KeyTypesMapT<KEY>;
        query(key: Table.PrimaryKey.KeyQueryMapT<KEY>, options?: Table.QueryOptions): Promise<DocumentClient.QueryOutput>;
        queryParams(key: Table.PrimaryKey.KeyQueryMapT<KEY>, options?: Table.QueryOptions): DocumentClient.QueryInput;
    }
}

// @public
export class KeyCondition {
    static beginsWith(value: string): KeyCondition.Resolver;
    static between<T extends Table.AttributeValues>(from: T, to: T): KeyCondition.Resolver;
    static compare<T extends Table.AttributeValues>(op: KeyCondition.CompareOperators, value: T): KeyCondition.Resolver;
    static eq<T extends Table.AttributeValues>(value: T): KeyCondition.Resolver;
    static ge<T extends Table.AttributeValues>(value: T): KeyCondition.Resolver;
    static gt<T extends Table.AttributeValues>(value: T): KeyCondition.Resolver;
    static le<T extends Table.AttributeValues>(value: T): KeyCondition.Resolver;
    static lt<T extends Table.AttributeValues>(value: T): KeyCondition.Resolver;
}

// @public
export namespace KeyCondition {
    export type AttributeResolver = StringResolver | NumberResolver | BinaryResolver;
    export type BinaryResolver = KeyCondition.Resolver<'B'>;
    export type CompareOperators = '=' | '<' | '<=' | '>' | '>=';
    export interface Expression {
        addCondition(condition: string): void;
        addPath(path: string): string;
        addValue(value: Table.AttributeValues): string;
        getExpression(): string | void;
    }
    export type NumberResolver = KeyCondition.Resolver<'N'>;
    export type Operators = CompareOperators | 'BETWEEN' | 'begins_with';
    export type Resolver<T = Table.PrimaryKey.AttributeTypes> = (name: string, exp: Expression, type?: T) => void;
    export type StringResolver = KeyCondition.Resolver<'S'>;
}

// @public
export class KeyConditionExpression implements KeyCondition.Expression {
    constructor(attributes: Table.ExpressionAttributes);
    addCondition(condition: string): void;
    static addParams(params: {
        KeyConditionExpression?: string;
    }, attributes: Table.ExpressionAttributes, key: Table.PrimaryKey.KeyQueryMap): void;
    addPath(path: string): string;
    addValue(value: Table.AttributeValues): string;
    attributes: Table.ExpressionAttributes;
    static buildExpression(key: Table.PrimaryKey.KeyQueryMap, exp: KeyCondition.Expression): string | void;
    conditions: string[];
    getExpression(): string | void;
}

// @public
export class Model implements Model.ModelBase {
    constructor(params: Model.ModelParams);
    create(data: Model.ModelCore, options?: Table.PutOptions): Promise<Model.PutOutput>;
    delete(key: Model.ModelCore, options?: Table.DeleteOptions): Promise<Model.DeleteOutput>;
    deleteParams(key: Model.ModelCore, options?: Table.DeleteOptions): DocumentClient.DeleteItemInput;
    get(key: Model.ModelCore, options?: Table.GetOptions): Promise<Model.GetOutput>;
    getContext(action: Table.ItemActions, options: Table.BaseOptions): Fields.TableContext;
    getParams(key: Model.ModelCore, options?: Table.GetOptions): DocumentClient.GetItemInput;
    static initSchema(schema: Model.ModelSchema, model: Model): void;
    name?: string;
    put(data: Model.ModelCore, options?: Table.PutOptions): Promise<Model.PutOutput>;
    putParams(item: Model.ModelCore, options?: Table.PutOptions): DocumentClient.PutItemInput;
    replace(data: Model.ModelCore, options?: Table.PutOptions): Promise<Model.PutOutput>;
    schema: Model.ModelSchema;
    static splitTableData(table: Table, data: Table.AttributeValuesMap): Model.TableData;
    table: Table;
    toModel(data: Table.AttributeValuesMap | undefined, context: Fields.ModelContext): Model.ModelOut | undefined;
    toTable(data: Model.ModelData, context: Fields.TableContext): Model.TableData;
    toTableUpdate(data: Model.ModelUpdate, context: Fields.TableContext): Model.TableUpdateData;
    update(data: Model.ModelUpdate, options?: Table.UpdateOptions): Promise<Model.UpdateOutput>;
    updateParams(item: Model.ModelUpdate, options?: Table.UpdateOptions): DocumentClient.UpdateItemInput;
}

// @public
export namespace Model {
    export interface BaseOutput<ITEM, RESULT> {
        item?: ITEM;
        result: RESULT;
    }
    export function createModel<KEY extends {
        [key: string]: any;
    }, MODEL extends KEY = KEY>(params: ModelParamsT<KEY, MODEL>): Model.ModelT<KEY, MODEL>;
    export interface DeleteOutput<T = ModelOut> extends BaseOutput<T, DocumentClient.DeleteItemOutput> {
    }
    export interface GetOutput<T = ModelOut> extends BaseOutput<T, DocumentClient.GetItemOutput> {
    }
    export interface ModelBase {
        name?: string;
        schema: Model.ModelSchema;
        table: Table;
    }
    export type ModelCore = {
        [key: string]: ModelType;
    };
    export type ModelCoreT<T> = {
        [P in keyof T]: Extract<T[P], ModelType>;
    };
    export type ModelData = {
        [key: string]: ModelType;
    };
    export type ModelOut = {
        [key: string]: ModelType;
    };
    export type ModelOutT<T> = {
        [P in keyof T]: Extract<T[P], ModelType>;
    };
    export interface ModelParams {
        name?: string;
        schema: Model.ModelSchema;
        table: Table;
    }
    export interface ModelParamsT<KEY, MODEL extends KEY = KEY> extends ModelParams {
        schema: ModelSchemaT<MODEL>;
    }
    export type ModelSchema = {
        [key: string]: Fields.Field;
    };
    export type ModelSchemaT<T extends {
        [key: string]: any;
    }> = {
        [P in keyof Required<T>]: Fields.Field;
    };
    export interface ModelT<KEY extends {
        [key: string]: any;
    }, MODEL extends KEY = KEY> extends Model {
        create(data: Model.ModelCoreT<MODEL>, options?: Table.PutOptions): Promise<Model.PutOutput<MODEL>>;
        delete(key: Model.ModelCoreT<KEY>, options?: Table.DeleteOptions): Promise<Model.DeleteOutput<MODEL>>;
        deleteParams(key: Model.ModelCoreT<KEY>, options?: Table.DeleteOptions): DocumentClient.DeleteItemInput;
        get(key: Model.ModelCoreT<KEY>, options?: Table.GetOptions): Promise<Model.GetOutput<MODEL>>;
        getParams(key: Model.ModelCoreT<KEY>, options?: Table.GetOptions): DocumentClient.GetItemInput;
        put(data: Model.ModelCoreT<MODEL>, options?: Table.PutOptions): Promise<Model.PutOutput<MODEL>>;
        putParams(data: Model.ModelCoreT<MODEL>, options?: Table.PutOptions): DocumentClient.PutItemInput;
        replace(data: Model.ModelCoreT<MODEL>, options?: Table.PutOptions): Promise<Model.PutOutput<MODEL>>;
        schema: Model.ModelSchemaT<MODEL>;
        toModel(data: Table.AttributeValuesMap): Model.ModelOutT<MODEL>;
        toTable(data: Model.ModelCoreT<MODEL>): Model.TableData;
        toTableUpdate(data: Model.ModelUpdateT<MODEL>): Model.TableUpdateData;
        update(data: Model.ModelUpdateT<MODEL>, options?: Table.UpdateOptions): Promise<Model.UpdateOutput<MODEL>>;
        updateParams(data: Model.ModelUpdateT<MODEL>, options?: Table.UpdateOptions): DocumentClient.UpdateItemInput;
    }
    export type ModelType = number | string | boolean | null | object;
    export type ModelUpdate = {
        [key: string]: ModelUpdateValue<ModelType>;
    };
    export type ModelUpdateT<T> = {
        [P in keyof Table.Optional<T>]: ModelUpdateValue<T[P]>;
    };
    export type ModelUpdateValue<T> = Extract<T, ModelType | Update.Resolver<Table.AttributeTypes>> | null;
    export interface PutOutput<T = ModelOut> extends BaseOutput<T, DocumentClient.PutItemOutput> {
    }
    export interface TableData {
        data: Table.AttributeValuesMap;
        item?: Table.AttributeValuesMap;
        key: Table.PrimaryKey.AttributeValuesMap;
    }
    export interface TableUpdateData {
        data: Update.ResolverMap;
        item?: Update.ResolverMap;
        key: Table.PrimaryKey.AttributeValuesMap;
    }
    export interface UpdateOutput<T = ModelOut> extends BaseOutput<T, DocumentClient.UpdateItemOutput> {
    }
}

// @public
export class Table {
    constructor(params: Table.TableParams);
    addGlobalIndexes(gsi: Index[]): void;
    addLocalIndexes(lsi: Index[]): void;
    static addParams<T extends Table.ExpressionParams>(params: T, options: Table.BaseOptions, type: 'filter' | 'condition', addParams?: Table.AddExpressionParams): T & Table.ExpressionParams;
    get client(): DocumentClient;
    createBinarySet(list: Table.BinaryValue[], options?: DocumentClient.CreateSetOptions): Table.BinarySetValue;
    createNumberSet(list: number[], options?: DocumentClient.CreateSetOptions): Table.NumberSetValue;
    createSet(list: string[] | number[] | Table.BinaryValue[], options?: DocumentClient.CreateSetOptions): Table.AttributeSetValues;
    createStringSet(list: string[], options?: DocumentClient.CreateSetOptions): Table.StringSetValue;
    delete(key: Table.PrimaryKey.AttributeValuesMap, options?: Table.DeleteOptions): Promise<DocumentClient.DeleteItemOutput>;
    deleteParams(key: Table.PrimaryKey.AttributeValuesMap, options?: Table.DeleteOptions): DocumentClient.DeleteItemInput;
    get(key: Table.PrimaryKey.AttributeValuesMap, options?: Table.GetOptions): Promise<DocumentClient.GetItemOutput>;
    static getKeyName(keySchema: Table.PrimaryKey.KeyTypesMap, type: Table.PrimaryKey.KeyTypes): string;
    getParams(key: Table.PrimaryKey.AttributeValuesMap, options?: Table.GetOptions): Table.GetInput;
    getPartitionKey(): string;
    static getPutAction(options?: Table.PutWriteOptions): Table.PutItemActions;
    getPutCondition(options: Table.PutWriteOptions | undefined): Condition.Resolver | void;
    getSortKey(): string;
    globalIndexes: Index[];
    static isPutAction(action: Table.ItemActions): boolean;
    keyAttributes: Table.PrimaryKey.AttributeTypesMap;
    keySchema: Table.PrimaryKey.KeyTypesMap;
    localIndexes: Index[];
    name: string;
    onError: (msg: string) => void;
    put(key: Table.PrimaryKey.AttributeValuesMap, items?: Table.AttributeValuesMap, options?: Table.PutOptions): Promise<DocumentClient.PutItemOutput>;
    putParams(key: Table.PrimaryKey.AttributeValuesMap, item?: Table.AttributeValuesMap, options?: Table.PutOptions): DocumentClient.PutItemInput;
    query(key: Table.PrimaryKey.KeyQueryMap, options?: Table.QueryOptions): Promise<DocumentClient.QueryOutput>;
    queryParams(key: Table.PrimaryKey.KeyQueryMap, options?: Table.QueryOptions): DocumentClient.QueryInput;
    scan(options?: Table.ScanOptions): Promise<DocumentClient.ScanOutput>;
    scanParams(options?: Table.ScanOptions): DocumentClient.ScanInput;
    update(key: Table.PrimaryKey.AttributeValuesMap, items?: Update.ResolverMap, options?: Table.UpdateOptions): Promise<DocumentClient.UpdateItemOutput>;
    updateParams(key: Table.PrimaryKey.AttributeValuesMap, item?: Update.ResolverMap, options?: Table.UpdateOptions): DocumentClient.UpdateItemInput;
}

// @public
export namespace Table {
    export type AddExpressionParams = (params: ExpressionParams, attributes: ExpressionAttributes) => void;
    export type AttributeSetValues = StringSetValue | NumberSetValue | BinarySetValue;
    export type AttributeTypes = 'B' | 'N' | 'S' | 'BOOL' | 'NULL' | 'L' | 'M' | 'BS' | 'NS' | 'SS';
    export type AttributeValues = null | string | number | boolean | BinaryValue | AttributeSetValues | MapValue | ListValue;
    export type AttributeValuesMap = {
        [key: string]: AttributeValues;
    };
    export interface BaseOptions<T = {}> {
        attributes?: Table.ExpressionAttributes;
        conditions?: Condition.Resolver[];
        context?: any;
        params?: Optional<T>;
    }
    export type BinarySetValue = DocumentClient.BinarySet;
    export type BinaryValue = DocumentClient.binaryType;
    export function createTable<KEY = Table.DefaultTableKey, ATTRIBUTES = KEY>(params: TableParamsT<KEY, ATTRIBUTES>): TableT<KEY, ATTRIBUTES>;
    export interface DefaultTableKey {
        P: PrimaryKey.PartitionString;
        S?: PrimaryKey.SortString;
    }
    export interface DeleteInput extends Omit<DocumentClient.DeleteItemInput, 'Expected' | 'ConditionalOperator'> {
    }
    export interface DeleteOptions extends BaseOptions<DeleteInput> {
    }
    export type ExpressionAttributeParams = {
        ExpressionAttributeNames?: ExpressionAttributeNameMap;
        ExpressionAttributeValues?: Table.AttributeValuesMap;
    };
    export interface ExpressionAttributes {
        addPath(name: string): string;
        addValue(value: Table.AttributeValues): string;
        getPaths(): ExpressionAttributeNameMap | void;
        getValues(): Table.AttributeValuesMap | void;
    }
    export type ExpressionParams = {
        ConditionExpression?: string;
        FilterExpression?: string;
        KeyConditionExpression?: string;
        UpdateExpression?: string;
    } & ExpressionAttributeParams;
    export interface GetInput extends Omit<DocumentClient.GetItemInput, 'AttributesToGet'> {
    }
    export interface GetOptions extends BaseOptions<GetInput> {
    }
    export type ItemActions = 'get' | 'delete' | PutItemActions | 'update';
    export type ListValue = AttributeValues[];
    export type MapValue = {
        [key: string]: AttributeValues;
    };
    export type NumberSetValue = DocumentClient.NumberSet;
    export type Optional<T> = {
        [P in keyof T]?: T[P];
    };
    export class PrimaryKey {
        static readonly BinaryType: {
            type: 'B';
        };
        static readonly NumberType: {
            type: 'N';
        };
        static readonly PartitionKeyType: {
            keyType: 'HASH';
        };
        static readonly SortKeyType: {
            keyType: 'RANGE';
        };
        static readonly StringType: {
            type: 'S';
        };
    }
    export namespace PrimaryKey {
        export type AttributeTypes = 'B' | 'N' | 'S';
        export type AttributeTypesMap = {
            [key: string]: {
                type: AttributeTypes;
            };
        };
        export type AttributeTypesMapT<T> = {
            [P in keyof Required<T>]: Extract<T[P], {
                type: AttributeTypes;
            }>;
        };
        export type AttributeValues = string | number | Table.BinaryValue;
        export type AttributeValuesMap = {
            [key: string]: AttributeValues;
        };
        export type AttributeValuesMapT<T> = {
            [P in keyof Required<T>]: Extract<T[P], Table.AttributeValues>;
        };
        export type KeyQueryMap = {
            [key: string]: AttributeValues | KeyCondition.AttributeResolver;
        };
        export type KeyQueryMapT<T> = {
            [P in keyof T]: Extract<T[P], Table.AttributeValues | KeyCondition.AttributeResolver>;
        };
        export type KeyTypes = 'HASH' | 'RANGE';
        export type KeyTypesMap = {
            [key: string]: {
                keyType: KeyTypes;
            };
        };
        export type KeyTypesMapT<T> = {
            [P in keyof Required<T>]: Extract<T[P], {
                keyType: KeyTypes;
            }>;
        };
        export type PartitionBinary = Table.BinaryValue | {
            type: 'B';
        } | {
            keyType: 'HASH';
        };
        export type PartitionNumber = number | {
            type: 'N';
        } | {
            keyType: 'HASH';
        };
        export type PartitionString = string | {
            type: 'S';
        } | {
            keyType: 'HASH';
        };
        export type SortBinary = Table.BinaryValue | {
            type: 'B';
        } | {
            keyType: 'RANGE';
        } | KeyCondition.BinaryResolver;
        export type SortNumber = number | {
            type: 'N';
        } | {
            keyType: 'RANGE';
        } | KeyCondition.NumberResolver;
        export type SortString = string | {
            type: 'S';
        } | {
            keyType: 'RANGE';
        } | KeyCondition.StringResolver;
    }
    export type ProjectionType = 'ALL' | 'KEYS_ONLY' | 'INCLUDE';
    export interface PutInput extends Omit<DocumentClient.PutItemInput, 'Expected' | 'ConditionalOperator'> {
    }
    export type PutItemActions = 'put' | 'put-new' | 'put-replace';
    export interface PutOptions extends BaseOptions<PutInput> {
        writeOptions?: PutWriteOptions;
    }
    export type PutWriteOptions = 'Always' | 'Exists' | 'NotExists';
    export interface QueryInput extends Omit<DocumentClient.QueryInput, 'AttributesToGet' | 'KeyConditions' | 'QueryFilter' | 'ConditionalOperator'> {
    }
    export interface QueryOptions extends BaseOptions<QueryInput> {
    }
    export interface ScanInput extends Omit<DocumentClient.ScanInput, 'AttributesToGet' | 'ScanFilter' | 'ConditionalOperator'> {
    }
    export interface ScanOptions extends BaseOptions<ScanInput> {
    }
    export type StringSetValue = DocumentClient.StringSet;
    export interface TableParams {
        client: DocumentClient | (() => DocumentClient);
        globalIndexes?: Index[];
        keyAttributes: Table.PrimaryKey.AttributeTypesMap;
        keySchema: Table.PrimaryKey.KeyTypesMap;
        localIndexes?: Index[];
        name: string;
        onError?: (msg: string) => void;
    }
    export interface TableParamsT<KEY, ATTRIBUTES> extends TableParams {
        keyAttributes: PrimaryKey.AttributeTypesMapT<ATTRIBUTES>;
        keySchema: PrimaryKey.KeyTypesMapT<KEY>;
    }
    export interface TableT<KEY = DefaultTableKey, ATTRIBUTES = KEY> extends Table {
        delete(key: PrimaryKey.AttributeValuesMapT<KEY>, options?: Table.DeleteOptions): Promise<DocumentClient.DeleteItemOutput>;
        deleteParams(key: PrimaryKey.AttributeValuesMapT<KEY>, options?: Table.DeleteOptions): DocumentClient.DeleteItemInput;
        get(key: PrimaryKey.AttributeValuesMapT<KEY>, options?: Table.GetOptions): Promise<DocumentClient.GetItemOutput>;
        getParams(key: PrimaryKey.AttributeValuesMapT<KEY>, options?: Table.GetOptions): Table.GetInput;
        keyAttributes: PrimaryKey.AttributeTypesMapT<ATTRIBUTES>;
        keySchema: PrimaryKey.KeyTypesMapT<KEY>;
        put(key: PrimaryKey.AttributeValuesMapT<KEY>, item?: Table.AttributeValuesMap, options?: Table.PutOptions): Promise<DocumentClient.PutItemOutput>;
        putParams(key: PrimaryKey.AttributeValuesMapT<KEY>, item?: Table.AttributeValuesMap, options?: Table.PutOptions): DocumentClient.PutItemInput;
        query(key: PrimaryKey.KeyQueryMapT<KEY>, options?: Table.QueryOptions): Promise<DocumentClient.QueryOutput>;
        queryParams(key: PrimaryKey.KeyQueryMapT<KEY>, options?: Table.QueryOptions): DocumentClient.QueryInput;
        scan(options?: ScanOptions): Promise<DocumentClient.ScanOutput>;
        scanParams(options?: Table.ScanOptions): DocumentClient.ScanInput;
        update(key: PrimaryKey.AttributeValuesMapT<KEY>, item?: Update.ResolverMap, options?: UpdateOptions): Promise<DocumentClient.UpdateItemOutput>;
        updateParams(key: PrimaryKey.AttributeValuesMapT<KEY>, item?: Update.ResolverMap, options?: Table.UpdateOptions): DocumentClient.UpdateItemInput;
    }
    export interface UpdateInput extends Omit<DocumentClient.UpdateItemInput, 'AttributeUpdates' | 'Expected' | 'ConditionalOperator'> {
    }
    export interface UpdateOptions extends BaseOptions<UpdateInput> {
    }
}

// @public
export class Update {
    static add(left: Update.OperandNumber, right: Update.OperandNumber): Update.Resolver<'N'>;
    static addToSet(value: Table.AttributeSetValues): Update.Resolver<'SS' | 'NS' | 'BS'>;
    static append(value: Update.OperandList): Update.Resolver<'L'>;
    static arithmetic(left: Update.OperandNumber | undefined, op: '+' | '-', right: Update.OperandNumber): Update.Resolver<'N'>;
    static dec(value: Update.OperandNumber): Update.Resolver<'N'>;
    static default<T extends Table.AttributeValues>(value: T): Update.Resolver<Table.AttributeTypes>;
    static del(): Update.Resolver<Table.AttributeTypes>;
    static delIndexes(indexes: number[]): Update.Resolver<'L'>;
    static inc(value: Update.OperandNumber): Update.Resolver<'N'>;
    static join(left?: Update.OperandList, right?: Update.OperandList): Update.Resolver<'L'>;
    static map(map: Update.ResolverMap): Update.Resolver<'M'>;
    static model<T>(map: Update.ResolverModel<T>): Update.Resolver<'M'>;
    static modelMap<T>(map: Update.ResolverModelMap<T>): Update.Resolver<'M'>;
    static path(path: string): Update.OperandFunction;
    static pathWithDefault<T extends Table.AttributeValues>(path: string, value: T): Update.OperandFunction;
    static prepend(value: Update.OperandList): Update.Resolver<'L'>;
    static removeFromSet(value: Table.AttributeSetValues): Update.Resolver<'SS' | 'NS' | 'BS'>;
    static set<T extends Table.AttributeValues>(value: Update.OperandValue<T>): Update.Resolver<Table.AttributeTypes>;
    static setIndexes(values: {
        [key: number]: Update.OperandValue;
    }): Update.Resolver<'L'>;
    static sub(left: Update.OperandNumber, right: Update.OperandNumber): Update.Resolver<'N'>;
}

// @public
export namespace Update {
    export type Binary = Table.BinaryValue | Update.Resolver<'B'>;
    export type BinarySet = Table.BinarySetValue | Update.Resolver<'BS'>;
    export type Boolean = boolean | Update.Resolver<'BOOL'>;
    export interface Expression {
        addAdd(value: string): void;
        addDelete(value: string): void;
        addPath(path: string): string;
        addRemove(value: string): void;
        addSet(value: string): void;
        addValue(value: Table.AttributeValues): string;
        getExpression(): string | void;
        resolveMap(map: Update.ResolverMap, name?: string): void;
        resolvePathValue(value: Update.OperandValue, name: string): string;
        resolveValue(value: Update.OperandValue, name: string): string;
    }
    export type List<T extends Table.AttributeValues = Table.AttributeValues> = T[] | Update.Resolver<'L'>;
    export type Map<T extends Table.AttributeValues = Table.AttributeValues> = {
        [key: string]: T;
    } | Update.Resolver<'M'>;
    export type Model<T> = T | Update.Resolver<'M'>;
    export type ModelList<T> = T[] | Update.Resolver<'L'>;
    export type ModelMap<T> = {
        [key: string]: T;
    } | Update.Resolver<'M'>;
    export type Null = null | Update.Resolver<'NULL'>;
    export type Number = number | Update.Resolver<'N'>;
    export type NumberSet = Table.NumberSetValue | Update.Resolver<'NS'>;
    export type OperandFunction = (name: string, exp: Update.Expression) => string;
    export type OperandList<T extends Table.AttributeValues = Table.AttributeValues> = OperandValue<string | T[]>;
    export type OperandNumber = OperandValue<string | number>;
    export type OperandValue<T extends Table.AttributeValues = Table.AttributeValues> = Table.AttributeValues | OperandFunction;
    export type Resolver<T> = (name: string, exp: Update.Expression, type?: T) => void;
    export type ResolverMap = ResolverMapT<Table.AttributeValues>;
    export type ResolverMapT<T> = {
        [key: string]: T | Resolver<Table.AttributeTypes> | OperandFunction | undefined;
    };
    export type ResolverModel<T> = {
        [P in keyof Table.Optional<T>]: ResolverModelValue<T[P]>;
    };
    export type ResolverModelMap<T> = {
        [key: string]: Update.ResolverModel<T>;
    };
    export type ResolverModelValue<T> = Extract<T, Table.AttributeValues | Update.Resolver<Table.AttributeTypes>> | null;
    export type String = string | Update.Resolver<'S'>;
    export type StringSet = Table.StringSetValue | Update.Resolver<'SS'>;
}

// @public
export class UpdateExpression implements Update.Expression {
    constructor(attributes: Table.ExpressionAttributes);
    addAdd(value: string): void;
    addDelete(value: string): void;
    addList: string[];
    static addParams(params: {
        UpdateExpression?: string;
    }, attributes: Table.ExpressionAttributes, updateMap?: Update.ResolverMap): void;
    addPath(name: string): string;
    addRemove(value: string): void;
    addSet(value: string): void;
    addValue(value: Table.AttributeValues): string;
    attributes: Table.ExpressionAttributes;
    static buildExpression(updateMap: Update.ResolverMap, exp: Update.Expression): string | void;
    deleteList: string[];
    getExpression(): string | void;
    removeList: string[];
    resolveMap(map: Update.ResolverMap, name?: string): void;
    resolvePathValue(value: Update.OperandValue, name: string): string;
    resolveValue(value: Update.OperandValue, name: string): string;
    setList: string[];
}

// @public
export function validateTable<KEY, ATTRIBUTES>(table: Table.TableT<KEY, ATTRIBUTES>): void;


// (No @packageDocumentation comment for this package)

```
